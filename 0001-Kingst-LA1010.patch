From 5250d4ea31c073f30c5029340f684bec8fa51087 Mon Sep 17 00:00:00 2001
From: Alexandr Ugnenko <ugnenko@mail.ru>
Date: Fri, 8 May 2020 16:13:58 +0300
Subject: [PATCH] Kingst-LA1010 support was implemented.

---
 Makefile.am                           |    6 +
 configure.ac                          |    1 +
 src/hardware/kingst-la1010/api.c      |  555 ++++++++++
 src/hardware/kingst-la1010/protocol.c | 1469 +++++++++++++++++++++++++
 src/hardware/kingst-la1010/protocol.h |  187 ++++
 5 files changed, 2218 insertions(+)
 create mode 100644 src/hardware/kingst-la1010/api.c
 create mode 100644 src/hardware/kingst-la1010/protocol.c
 create mode 100644 src/hardware/kingst-la1010/protocol.h

diff --git a/Makefile.am b/Makefile.am
index 2e111e93..6f1b9a38 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -417,6 +417,12 @@ src_libdrivers_la_SOURCES += \
 	src/hardware/kern-scale/protocol.c \
 	src/hardware/kern-scale/api.c
 endif
+if HW_KINGST_LA1010
+src_libdrivers_la_SOURCES += \
+	src/hardware/kingst-la1010/protocol.h \
+	src/hardware/kingst-la1010/protocol.c \
+	src/hardware/kingst-la1010/api.c
+endif
 if HW_KORAD_KAXXXXP
 src_libdrivers_la_SOURCES += \
 	src/hardware/korad-kaxxxxp/protocol.h \
diff --git a/configure.ac b/configure.ac
index 6cc15bf7..2a2fe411 100644
--- a/configure.ac
+++ b/configure.ac
@@ -286,6 +286,7 @@ SR_DRIVER([Ikalogic Scanaplus], [ikalogic-scanaplus], [libftdi])
 SR_DRIVER([IPDBG LA], [ipdbg-la])
 SR_DRIVER([Kecheng KC-330B], [kecheng-kc-330b], [libusb])
 SR_DRIVER([KERN scale], [kern-scale], [serial_comm])
+SR_DRIVER([Kingst LA1010], [kingst-la1010], [libusb])
 SR_DRIVER([Korad KAxxxxP], [korad-kaxxxxp], [serial_comm])
 SR_DRIVER([Lascar EL-USB], [lascar-el-usb], [libusb])
 SR_DRIVER([LeCroy LogicStudio], [lecroy-logicstudio], [libusb])
diff --git a/src/hardware/kingst-la1010/api.c b/src/hardware/kingst-la1010/api.c
new file mode 100644
index 00000000..80071885
--- /dev/null
+++ b/src/hardware/kingst-la1010/api.c
@@ -0,0 +1,555 @@
+/*
+ * This file is part of the libsigrok project.
+ *
+ * Copyright (C) 2018 Alexandr Ugnenko <ugnenko@mail.ru>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include "protocol.h"
+
+static const struct kingst_la1010_profile la1010_profile = {
+		.vid = 0x77A1,
+		.pid = 0x01A2,
+		.vendor = "Kingst",
+		.model = "LA1010",
+		.model_version = 0,
+//		.fx_firmware = "LA1010.fw",
+		.fx_firmware = 0,	// file name will be retrieved from PID
+		.spartan_firmware = "LA1010.bitstream",
+		.dev_caps = DEV_CAPS_16BIT,
+		.usb_manufacturer = NULL,
+		.usb_product = NULL };
+
+static const uint32_t scanopts[] = { SR_CONF_CONN, };
+
+static const uint32_t drvopts[] = { SR_CONF_LOGIC_ANALYZER, };
+
+static const uint32_t devopts[] = {
+		SR_CONF_CONTINUOUS,
+		SR_CONF_LIMIT_SAMPLES | SR_CONF_GET | SR_CONF_SET, SR_CONF_CONN | SR_CONF_GET,
+		SR_CONF_SAMPLERATE | SR_CONF_GET | SR_CONF_SET | SR_CONF_LIST,
+		SR_CONF_VOLTAGE_THRESHOLD | SR_CONF_GET | SR_CONF_SET | SR_CONF_LIST,
+		SR_CONF_TRIGGER_MATCH | SR_CONF_LIST,
+		SR_CONF_CAPTURE_RATIO | SR_CONF_GET | SR_CONF_SET, };
+
+static const int32_t trigger_matches[] = {
+		SR_TRIGGER_ZERO,
+		SR_TRIGGER_ONE,
+		SR_TRIGGER_RISING,
+		SR_TRIGGER_FALLING,
+		SR_TRIGGER_EDGE, };
+
+static const uint64_t samplerates[] = {
+		SR_KHZ(20),
+		SR_KHZ(50),
+		SR_KHZ(100),
+		SR_KHZ(200),
+		SR_KHZ(250),
+		SR_KHZ(500),
+		SR_MHZ(1),
+		SR_MHZ(2),
+		SR_MHZ(4),
+		SR_MHZ(5),
+		SR_MHZ(8),
+		SR_MHZ(10),
+		SR_KHZ(12500),
+		SR_MHZ(16),
+		SR_MHZ(25),
+		SR_MHZ(32),
+		SR_MHZ(40),
+		SR_MHZ(50),
+		SR_MHZ(80),
+		SR_MHZ(100),
+};
+
+/*
+ * Kingst LA1010 software provides next voltage leves:
+ * TTL          -> 1.58 V
+ * CMOS 5       -> 2.5 V
+ * CMOS 3.3     -> 1.65
+ * CMOS 3       -> 1.5 V
+ * CMOS 2.5     -> 1.25 V
+ * CMOS 1.8     -> 0.9 V
+ * CMOS 1.5     -> 0.75 V
+ *
+ * and 'User Defined' -- between -4 V and 4 V
+ * 'User Defined' not implemented
+ */
+static const double thresholds[][2] = {
+		{ 1.58, 1.58 },     // TTL
+		{ 2.5, 2.5 },       // CMOS 5
+		{ 1.65, 1.65 },     // CMOS 3.3
+		{ 1.5, 1.5 },       // CMOS 3
+		{ 1.25, 1.25 },     // CMOS 2.5
+		{ 0.9, 0.9 },       // CMOS 1.8
+		{ 0.75, 0.75 },     // CMOS 1.5
+		};
+
+static GSList* scan(struct sr_dev_driver *di, GSList *options) {
+
+	struct drv_context *drvc;
+	struct dev_context *devc;
+	struct sr_dev_inst *sdi;
+	struct sr_usb_dev_inst *usb;
+	struct sr_channel *ch;
+	struct sr_channel_group *cg;
+	struct sr_config *src;
+	const struct kingst_la1010_profile *prof;
+	GSList *l, *devices, *conn_devices;
+	struct libusb_device_descriptor des;
+	libusb_device **devlist;
+	struct libusb_device_handle *hdl;
+	int ret, i, j;
+	int num_logic_channels = 0;
+	const char *conn;
+	char manufacturer[64], product[64], serial_num[64], connection_id[64];
+	char channel_name[32];
+
+	drvc = di->context;
+	hdl = NULL;
+	conn = NULL;
+
+	for (l = options; l; l = l->next) {
+		src = l->data;
+		switch (src->key) {
+		case SR_CONF_CONN:
+			conn = g_variant_get_string(src->data, NULL);
+			break;
+		}
+	}
+	if (conn)
+		conn_devices = sr_usb_find(drvc->sr_ctx->libusb_ctx, conn);
+	else
+		conn_devices = NULL;
+
+	/* Find all Kingst LA1010 compatible devices and upload firmware to them. */
+	devices = NULL;
+	libusb_get_device_list(drvc->sr_ctx->libusb_ctx, &devlist);
+	for (i = 0; devlist[i]; i++) {
+
+		if (hdl) {
+			libusb_close(hdl);
+			hdl = NULL;
+		}
+
+		if (conn) {
+			usb = NULL;
+			for (l = conn_devices; l; l = l->next) {
+				usb = l->data;
+				if ((usb->bus == libusb_get_bus_number(devlist[i]))
+						&& (usb->address == libusb_get_device_address(devlist[i])))
+					break;
+			}
+			if (!l)
+				/* This device matched none of the ones that
+				 * matched the conn specification. */
+				continue;
+		}
+
+		libusb_get_device_descriptor(devlist[i], &des);
+
+		if ((des.idVendor != la1010_profile.vid)
+				|| (des.idProduct != la1010_profile.pid))
+			continue;
+
+		if ((ret = libusb_open(devlist[i], &hdl)) < 0) {
+			sr_warn("Failed to open potential device with " "VID:PID %04x:%04x: %s.",
+						des.idVendor,
+						des.idProduct,
+						libusb_error_name(ret));
+			continue;
+		}
+
+		if (des.iManufacturer == 0) {
+			manufacturer[0] = '\0';
+		} else if ((ret = libusb_get_string_descriptor_ascii(hdl,
+																des.iManufacturer,
+																(unsigned char*) manufacturer,
+																sizeof(manufacturer))) < 0) {
+			sr_warn("Failed to get manufacturer string descriptor: %s.",
+						libusb_error_name(ret));
+			continue;
+		}
+
+		if (des.iProduct == 0) {
+			product[0] = '\0';
+		} else if ((ret = libusb_get_string_descriptor_ascii(hdl,
+																des.iProduct,
+																(unsigned char*) product,
+																sizeof(product))) < 0) {
+			sr_warn("Failed to get product string descriptor: %s.",
+						libusb_error_name(ret));
+			continue;
+		}
+
+		if (des.iSerialNumber == 0) {
+			serial_num[0] = '\0';
+		} else if ((ret = libusb_get_string_descriptor_ascii(hdl,
+																des.iSerialNumber,
+																(unsigned char*) serial_num,
+																sizeof(serial_num))) < 0) {
+			sr_warn("Failed to get serial number string descriptor: %s.",
+						libusb_error_name(ret));
+			continue;
+		}
+
+		usb_get_port_path(devlist[i], connection_id, sizeof(connection_id));
+
+		prof = NULL;
+		if ((des.idVendor == la1010_profile.vid)
+				&& (des.idProduct == la1010_profile.pid)
+				&& (!la1010_profile.usb_manufacturer
+						|| !strcmp(manufacturer,
+								la1010_profile.usb_manufacturer))
+				&& (!la1010_profile.usb_product
+						|| !strcmp(product, la1010_profile.usb_product))) {
+			prof = &la1010_profile;
+		}
+
+		if (!prof) {
+			libusb_close(hdl);
+			hdl = NULL;
+			continue;
+		}
+
+		sdi = g_malloc0(sizeof(struct sr_dev_inst));
+		sdi->status = SR_ST_INITIALIZING;
+		sdi->vendor = g_strdup(prof->vendor);
+		sdi->model = g_strdup(prof->model);
+		sdi->version = g_strdup(prof->model_version);
+		sdi->serial_num = g_strdup(serial_num);
+		sdi->connection_id = g_strdup(connection_id);
+
+		/* Fill in channellist according to this device's profile. */
+		num_logic_channels = prof->dev_caps & DEV_CAPS_16BIT ? 16 : 8;
+
+		/* Logic channels, all in one channel group. */
+		cg = g_malloc0(sizeof(struct sr_channel_group));
+		cg->name = g_strdup("Logic");
+		for (j = 0; j < num_logic_channels; j++) {
+			sprintf(channel_name, "D%d", j);
+			ch = sr_channel_new(sdi, j, SR_CHANNEL_LOGIC, TRUE, channel_name);
+			cg->channels = g_slist_append(cg->channels, ch);
+		}
+		sdi->channel_groups = g_slist_append(NULL, cg);
+
+		devc = kingst_la1010_dev_new();
+		devc->profile = prof;
+		sdi->priv = devc;
+		devices = g_slist_append(devices, sdi);
+
+		devc->samplerates = samplerates;
+		devc->num_samplerates = ARRAY_SIZE(samplerates);
+
+		devc->pwm[0].freq = 1000;
+		devc->pwm[0].duty = 50;
+		devc->pwm[0].enabled = 0;
+		devc->pwm[1].freq = 1000;
+		devc->pwm[1].duty = 50;
+		devc->pwm[1].enabled = 0;
+
+		if (kingst_la1010_has_fx_firmware(hdl) == 0) {
+			/* Already has the firmware, so fix the new address. */
+			sdi->status = SR_ST_INACTIVE;
+			sdi->inst_type = SR_INST_USB;
+			sdi->conn = sr_usb_dev_inst_new(libusb_get_bus_number(devlist[i]),
+											libusb_get_device_address(devlist[i]),
+											NULL);
+		} else {
+			if (kingst_la1010_upload_cypress_firmware(drvc->sr_ctx,
+														hdl,
+														prof) == SR_OK) {
+				/* Store when this device's FW was updated. */
+				devc->fw_updated = g_get_monotonic_time();
+				sr_dbg("FX2 firmware was uploaded to Kingst LA1010 device.");
+			} else
+				sr_err("Firmware upload failed for " "device %d.%d (logical).",
+							libusb_get_bus_number(devlist[i]),
+							libusb_get_device_address(devlist[i]));
+
+			sdi->inst_type = SR_INST_USB;
+			sdi->conn = sr_usb_dev_inst_new(libusb_get_bus_number(devlist[i]),
+											0xff,
+											NULL);
+		}
+	}
+
+	if (hdl) {
+		libusb_close(hdl);
+		hdl = NULL;
+	}
+
+	libusb_free_device_list(devlist, 1);
+	g_slist_free_full(conn_devices, (GDestroyNotify) sr_usb_dev_inst_free);
+
+	return std_scan_complete(di, devices);
+}
+
+static int dev_open(struct sr_dev_inst *sdi) {
+	struct sr_usb_dev_inst *usb;
+	struct dev_context *devc;
+	int ret;
+	int64_t timediff_us, timediff_ms;
+
+	devc = sdi->priv;
+	usb = sdi->conn;
+
+	/*
+	 * If the firmware was recently uploaded, wait up to MAX_RENUM_DELAY_MS
+	 * milliseconds for the FX2 to renumerate.
+	 */
+	ret = SR_ERR;
+	if (devc->fw_updated > 0) {
+		sr_info("Waiting for device to reset.");
+		/* Takes >= 300ms for the FX2 to be gone from the USB bus. */
+		g_usleep(300 * 1000);
+		timediff_ms = 0;
+		while (timediff_ms < MAX_RENUM_DELAY_MS) {
+			if ((ret = kingst_la1010_dev_open(sdi)) == SR_OK)
+				break;
+			g_usleep(100 * 1000);
+
+			timediff_us = g_get_monotonic_time() - devc->fw_updated;
+			timediff_ms = timediff_us / 1000;
+			sr_spew("Waited %" PRIi64 "ms.", timediff_ms);
+		}
+		if (ret != SR_OK) {
+			sr_err("Device failed to renumerate.");
+			return SR_ERR;
+		}
+		sr_info("Device came back after %" PRIi64 "ms.", timediff_ms);
+	} else {
+		sr_info("Cypress firmware upload was not needed.");
+		ret = kingst_la1010_dev_open(sdi);
+	}
+
+	if (ret != SR_OK) {
+		sr_err("Unable to open device.");
+		return SR_ERR;
+	}
+
+	ret = libusb_claim_interface(usb->devhdl, USB_INTERFACE);
+	if (ret != 0) {
+		switch (ret) {
+		case LIBUSB_ERROR_BUSY:
+			sr_err(
+					"Unable to claim USB interface. Another " "program or driver has already claimed it.");
+			break;
+		case LIBUSB_ERROR_NO_DEVICE:
+			sr_err("Device has been disconnected.");
+			break;
+		default:
+			sr_err("Unable to claim interface: %s.", libusb_error_name(ret));
+			break;
+		}
+
+		return SR_ERR;
+	}
+
+	sr_dbg("Checking Cypress firmware...");
+
+	ret = kingst_la1010_has_fx_firmware(usb->devhdl);
+	if (ret) {
+		sr_err("Cypress wasn't initialized. Return status: 0x%x", ret);
+		return SR_ERR;
+	}
+
+	sr_dbg("Upload Spartan firmware...");
+	ret = kingst_la1010_upload_spartan_firmware(sdi);
+	if (ret) {
+		sr_err("Upload Spartan firmware failed. Return status: 0x%x", ret);
+		return SR_ERR;
+	}
+
+	ret = kingst_la1010_init_spartan(usb->devhdl);
+	if (ret) {
+		sr_err("Initialization of Spartan failed. Error: %s",
+				libusb_error_name(ret));
+		return SR_ERR;
+	}
+
+	if (devc->cur_samplerate == 0) {
+		/* Samplerate hasn't been set; default to the slowest one. */
+		devc->cur_samplerate = devc->samplerates[0];
+	}
+
+	sr_dbg("Kingst LA1010 initialization done.");
+
+	return SR_OK;
+}
+
+static int dev_close(struct sr_dev_inst *sdi) {
+	struct sr_usb_dev_inst *usb;
+
+	usb = sdi->conn;
+
+	if (!usb->devhdl)
+		return SR_ERR_BUG;
+
+	sr_info("Closing device on %d.%d (logical) / %s (physical) interface %d.",
+			usb->bus, usb->address, sdi->connection_id, USB_INTERFACE);
+	libusb_release_interface(usb->devhdl, USB_INTERFACE);
+	libusb_close(usb->devhdl);
+	usb->devhdl = NULL;
+
+	return SR_OK;
+}
+
+static int config_get(uint32_t key, GVariant **data,
+		const struct sr_dev_inst *sdi, const struct sr_channel_group *cg) {
+	unsigned int i;
+	struct dev_context *devc;
+	struct sr_usb_dev_inst *usb;
+
+	(void) cg;
+
+	if (!sdi)
+		return SR_ERR_ARG;
+
+	devc = sdi->priv;
+
+	switch (key) {
+	case SR_CONF_CONN:
+		if (!sdi->conn)
+			return SR_ERR_ARG;
+		usb = sdi->conn;
+		if (usb->address == 255)
+			/* Device still needs to re-enumerate after firmware
+			 * upload, so we don't know its (future) address. */
+			return SR_ERR;
+		*data = g_variant_new_printf("%d.%d", usb->bus, usb->address);
+		break;
+	case SR_CONF_LIMIT_SAMPLES:
+		*data = g_variant_new_uint64(devc->limit_samples);
+		break;
+	case SR_CONF_SAMPLERATE:
+		*data = g_variant_new_uint64(devc->cur_samplerate);
+		break;
+	case SR_CONF_CAPTURE_RATIO:
+		*data = g_variant_new_uint64(devc->capture_ratio);
+		break;
+	case SR_CONF_VOLTAGE_THRESHOLD:
+		if (!sdi)
+			return SR_ERR;
+		devc = sdi->priv;
+		for (i = 0; i < ARRAY_SIZE(thresholds); i++) {
+			if (devc->selected_voltage_level != i)
+				continue;
+			*data = std_gvar_tuple_double(thresholds[i][0], thresholds[i][1]);
+			return SR_OK;
+		}
+		return SR_ERR;
+	default:
+		return SR_ERR_NA;
+	}
+
+	return SR_OK;
+}
+
+static int config_set(uint32_t key, GVariant *data,
+		const struct sr_dev_inst *sdi, const struct sr_channel_group *cg) {
+	struct dev_context *devc;
+	struct sr_usb_dev_inst *usb;
+	int idx;
+
+	(void) cg;
+
+	if (!sdi)
+		return SR_ERR_ARG;
+
+	devc = sdi->priv;
+
+	switch (key) {
+	case SR_CONF_SAMPLERATE:
+		if ((idx = std_u64_idx(data, devc->samplerates, devc->num_samplerates))
+				< 0)
+			return SR_ERR_ARG;
+		devc->cur_samplerate = devc->samplerates[idx];
+		break;
+	case SR_CONF_LIMIT_SAMPLES:
+		devc->limit_samples = g_variant_get_uint64(data);
+		break;
+	case SR_CONF_CAPTURE_RATIO:
+		devc->capture_ratio = g_variant_get_uint64(data);
+		break;
+	case SR_CONF_VOLTAGE_THRESHOLD:
+		if ((idx = std_double_tuple_idx(data, ARRAY_AND_SIZE(thresholds))) < 0)
+			return SR_ERR_ARG;
+		devc->selected_voltage_level = idx;
+		usb = sdi->conn;
+		kingst_la1010_set_logic_level(usb->devhdl, thresholds[idx][0]);
+		break;
+	default:
+		return SR_ERR_NA;
+	}
+
+	return SR_OK;
+}
+
+static int config_list(uint32_t key, GVariant **data,
+		const struct sr_dev_inst *sdi, const struct sr_channel_group *cg) {
+	struct dev_context *devc;
+
+	devc = (sdi) ? sdi->priv : NULL;
+
+	if (!cg) {
+		switch (key) {
+		case SR_CONF_SCAN_OPTIONS:
+		case SR_CONF_DEVICE_OPTIONS:
+			return STD_CONFIG_LIST(key, data, sdi, cg, scanopts, drvopts,
+					devopts);
+		case SR_CONF_SAMPLERATE:
+			if (!devc)
+				return SR_ERR_NA;
+			*data = std_gvar_samplerates(devc->samplerates,
+					devc->num_samplerates);
+			break;
+		case SR_CONF_VOLTAGE_THRESHOLD:
+			*data = std_gvar_thresholds(ARRAY_AND_SIZE(thresholds));
+			break;
+		case SR_CONF_TRIGGER_MATCH:
+			*data = std_gvar_array_i32(ARRAY_AND_SIZE(trigger_matches));
+			break;
+		default:
+			return SR_ERR_NA;
+		}
+	} else {
+		return SR_ERR_NA;
+	}
+
+	return SR_OK;
+}
+
+static int dev_acquisition_start(const struct sr_dev_inst *sdi) {
+	sr_dbg("dev_acquisition_start(): start sampling");
+	return kingst_la1010_acquisition_start(sdi);
+}
+
+static int dev_acquisition_stop(struct sr_dev_inst *sdi) {
+	sr_dbg("dev_acquisition_start(): stop sampling");
+	return kingst_la1010_acquisition_stop(sdi);
+}
+
+SR_PRIV struct sr_dev_driver kingst_la1010_driver_info = { .name =
+		"kingst-la1010", .longname = "Kingst LA1010", .api_version = 1, .init =
+		std_init, .cleanup = std_cleanup, .scan = scan,
+		.dev_list = std_dev_list, .dev_clear = std_dev_clear, .config_get =
+				config_get, .config_set = config_set,
+		.config_list = config_list, .dev_open = dev_open,
+		.dev_close = dev_close, .dev_acquisition_start = dev_acquisition_start,
+		.dev_acquisition_stop = dev_acquisition_stop, .context = NULL, };
+
+SR_REGISTER_DEV_DRIVER(kingst_la1010_driver_info);
diff --git a/src/hardware/kingst-la1010/protocol.c b/src/hardware/kingst-la1010/protocol.c
new file mode 100644
index 00000000..64b0bb61
--- /dev/null
+++ b/src/hardware/kingst-la1010/protocol.c
@@ -0,0 +1,1469 @@
+/*
+ * This file is part of the libsigrok project.
+ *
+ * Copyright (C) 2018 Alexandr Ugnenko <ugnenko@mail.ru>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.	If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <libusb.h>
+
+#include "protocol.h"
+
+#define USB_TIMEOUT 1000
+
+
+static int read_hex_digit(unsigned char *firmware, size_t fw_size, size_t *offset);
+static int read_hex_byte(unsigned char *firmware, size_t fw_size, size_t *offset);
+static int read_hex_line(unsigned char *firmware,
+							size_t fw_size,
+							size_t *offset,
+							uint16_t *addr,
+							unsigned char *buffer);
+static int upload_cypress_firmware(struct sr_context *ctx,
+									struct libusb_device_handle *hdl,
+									const char *fw_file_name);
+
+static void finish_acquisition(const struct sr_dev_inst *sdi);
+static void free_transfer(struct libusb_transfer *transfer);
+static void resubmit_transfer(struct libusb_transfer *transfer);
+static size_t convert_sample_data(struct dev_context *devc,
+									uint8_t *dest,
+									size_t destcnt,
+									const uint8_t *src,
+									size_t srccnt);
+static int command_start_acquisition(const struct sr_dev_inst *sdi);
+static int start_transfers(const struct sr_dev_inst *sdi);
+
+static unsigned int to_bytes_per_ms(unsigned int samplerate,
+									uint8_t num_channels);
+static size_t get_buffer_size(struct dev_context *devc);
+static unsigned int get_number_of_transfers(struct dev_context *devc);
+static unsigned int get_timeout(struct dev_context *devc);
+
+static void LIBUSB_CALL
+abort_acquisition_request_cb(struct libusb_transfer *transfer);
+//void LIBUSB_CALL
+//upload_transfer_complete_cb(struct libusb_transfer *xfr);
+static void LIBUSB_CALL
+receive_transfer(struct libusb_transfer *transfer);
+
+static int control_in(libusb_device_handle *handle,
+						uint8_t request,
+						uint16_t value,
+						uint8_t *data,
+						uint16_t size);
+
+static int control_out(libusb_device_handle *handle,
+						uint8_t request,
+						uint16_t value,
+						uint8_t *data,
+						uint16_t size);
+
+static int upload_bindata_sync(libusb_device_handle *handle,
+								uint8_t *data,
+								int size,
+								int trans_size);
+
+
+int read_hex_digit(unsigned char *firmware, size_t fw_size, size_t *offset) {
+	uint8_t data;
+
+	if (*offset >= fw_size) {
+		sr_err("read_hex_digit(): Unexpected end of data (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	data = firmware[*offset];
+	*offset += 1;
+	if ((data >= '0')
+			&& (data <= '9')) {
+		data -= '0';
+	} else if ((data >= 'A')
+			&& (data <= 'F')) {
+		data -= 0x37;
+	} else if ((data >= 'a')
+			&& (data <= 'f')) {
+		data -= 0x57;
+	} else {
+		sr_err("read_hex_digit(): Wrong hex digit: %c (offset %lu)", data, *offset);
+		return SR_ERR;
+	}
+	return data;
+}
+
+int read_hex_byte(unsigned char *firmware, size_t fw_size, size_t *offset) {
+	uint8_t d;
+	int data;
+
+	data = read_hex_digit(firmware, fw_size, offset);
+	if (data >= 0) {
+		d = data << 4;
+		data = read_hex_digit(firmware, fw_size, offset);
+		if (data >= 0) {
+			data += d;
+		}
+	}
+	return data;
+}
+
+int read_hex_line(unsigned char *firmware,
+					size_t fw_size,
+					size_t *offset,
+					uint16_t *addr,
+					unsigned char *buffer) {
+	int data;
+	uint8_t size, i, checksum;
+
+	if (*offset >= fw_size) {
+		sr_err("read_hex_line(): Unexpected end of data (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	if (firmware[*offset] != ':') {
+		sr_err("read_hex_line(): Wrong hex line prefix, expected ':' (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	*offset += 1;
+
+	// size -- 1 byte
+	data = read_hex_byte(firmware, fw_size, offset);
+	if (data < 0) {
+		sr_err("read_hex_line(): Wrong size (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	checksum = data;
+	size = data;
+	if (size > 0x10) {
+		sr_err("read_hex_line(): Size greater than 0x10, size: %02X (offset %lu)", size, *offset);
+		return SR_ERR;
+	}
+
+	// address -- 2 byte
+	data = read_hex_byte(firmware, fw_size, offset);
+	if (data < 0) {
+		sr_err("read_hex_line(): Wrong address first byte (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	checksum += data;
+	*addr = data << 8;
+	data = read_hex_byte(firmware, fw_size, offset);
+	if (data < 0) {
+		sr_err("read_hex_line(): Wrong address second byte (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	checksum += data;
+	*addr += data;
+
+	// type -- 1 byte
+	data = read_hex_byte(firmware, fw_size, offset);
+	if (data < 0) {
+		sr_err("read_hex_line(): Wrong type (offset %lu)", *offset);
+		return SR_ERR;
+	}
+	checksum += data;
+	if (data == 0x01) {
+		return 0;	// End of data
+	}
+
+	// data -- 'size' bytes
+	for (i = 0; i < size; i++) {
+		data = read_hex_byte(firmware, fw_size, offset);
+		if (data < 0) {
+			sr_err("read_hex_line(): Wrong data byte (offset %lu)", *offset);
+			return SR_ERR;
+		}
+		checksum += data;
+		buffer[i] = data;
+	}
+
+	// checksum -- 1 byte
+	data = read_hex_byte(firmware, fw_size, offset);
+	if (data < 0) {
+		sr_err("read_hex_line(): Wrong checksum byte (offset %lu)", *offset);
+		return SR_ERR;
+	}
+
+	if ((uint8_t) (checksum + data)) {
+		sr_err("read_hex_line(): Wrong checksum, given %02X, expected %02X (offset %lu)",
+					(uint8_t) (0 - checksum),
+					(uint8_t) data,
+					*offset);
+		return SR_ERR;
+	}
+
+	// end of line
+	while (firmware[*offset] != ':') {
+		*offset += 1;
+		if (*offset >= fw_size) {
+			sr_err("read_hex_line(): Unexpected end of data (offset %lu)", *offset);
+			return SR_ERR;
+		}
+	}
+
+	return size;
+}
+
+/*
+ * Check if the fx firmware was uploaded to cypress.
+ * If FX firmware was loaded the cypress returns 0xFB04 (may be firmware version?).
+ */
+int kingst_la1010_has_fx_firmware(struct libusb_device_handle *hdl) {
+	int err;
+	struct libusb_device * dev;
+ 	struct libusb_config_descriptor * config;
+
+	dev = libusb_get_device(hdl);
+	err = libusb_get_active_config_descriptor(dev, &config);
+	if (err) {
+		sr_err(
+				"kingst_la1010_has_fx_firmware(): get active usb config descriptor failed. libusb err: %s",
+				libusb_error_name(err));
+		return err;
+	}
+	if (config->bNumInterfaces == 1) {
+		if (config->interface->altsetting->bNumEndpoints == 2) {
+			return SR_OK;
+		} else {
+			sr_err(
+					"kingst_la1010_has_fx_firmware(): iface->altsetting->bNumEndpoints: %d",
+					config->interface->altsetting->bNumEndpoints);
+		}
+	} else {
+		sr_err(
+				"kingst_la1010_has_fx_firmware(): config->bNumInterfaces: %d",
+				config->bNumInterfaces);
+	}
+
+	return SR_ERR;
+}
+
+int upload_cypress_firmware(struct sr_context *ctx,
+							struct libusb_device_handle *hdl,
+							const char *fw_file_name) {
+	size_t s, offset, fw_size;
+	uint16_t addr;
+	int res;
+	unsigned char *firmware, buffer[16];
+
+	s = strlen(fw_file_name);
+	if (s > 0) {
+		if ((res = libusb_set_configuration(hdl, USB_CONFIGURATION)) < 0) {
+			sr_err("upload_cypress_firmware(): Unable to set configuration: %s",
+					libusb_error_name(res));
+			return SR_ERR;
+		}
+		if ((ezusb_reset(hdl, 1)) < 0) {
+			sr_err("upload_cypress_firmware(): Reset Cypress for upload FW failed");
+			return SR_ERR;
+		}
+		if (memcmp(fw_file_name + (s - 3), "hex", 3)) {
+			// binary
+			if (ezusb_install_firmware(ctx, hdl, fw_file_name) < 0) {
+				sr_err("upload_cypress_firmware(): Upload binary FW failed");
+				return SR_ERR;
+			}
+		} else {
+			// Intel-HEX
+			firmware = sr_resource_load(ctx,
+										SR_RESOURCE_FIRMWARE,
+										fw_file_name,
+										&fw_size,
+										1 << 16);
+
+			if (!firmware) {
+				sr_err("upload_cypress_firmware(): Read Intel-HEX file failed");
+				return SR_ERR;
+			}
+
+			offset = 0;
+			res = read_hex_line(firmware, fw_size, &offset, &addr, buffer);
+			while (res > 0) {
+				res = control_out(hdl, 0xA0, addr, buffer, res);
+				if (res < 0) {
+					break;
+				}
+				res = read_hex_line(firmware, fw_size, &offset, &addr, buffer);
+			}
+
+			g_free(firmware);
+
+			if (res < 0) {
+				sr_err("upload_cypress_firmware(): Upload Intel-HEX FW failed");
+				return SR_ERR;
+			}
+		}
+		if ((ezusb_reset(hdl, 0)) < 0) {
+			sr_err("upload_cypress_firmware(): Reset Cypress for upload FW failed");
+			return SR_ERR;
+		}
+	} else {
+		sr_err("upload_cypress_firmware(): FW file name has null size");
+		return SR_ERR;
+	}
+	return SR_OK;
+}
+
+
+/*
+ * Upload spartan bitstream.
+ */
+int kingst_la1010_upload_cypress_firmware(struct sr_context *ctx,
+											struct libusb_device_handle *hdl,
+											const struct kingst_la1010_profile *prof) {
+	char fw_file_name[16];
+	int res;
+
+	if (prof->fx_firmware) {
+		res = upload_cypress_firmware(ctx, hdl, prof->fx_firmware);
+	} else {
+		snprintf(fw_file_name, 16, "fw%04X.hex", prof->pid);
+		res = upload_cypress_firmware(ctx, hdl, fw_file_name);
+		if (res < 0) {
+			snprintf(fw_file_name, 16, "fw%04X.fw", prof->pid);
+			res = upload_cypress_firmware(ctx, hdl, fw_file_name);
+		}
+	}
+	return res;
+}
+
+/*
+ * Upload spartan bitstream.
+ */
+int kingst_la1010_upload_spartan_firmware(const struct sr_dev_inst *sdi) {
+	struct drv_context *drvc;
+	struct dev_context *devc;
+	struct sr_usb_dev_inst *usb;
+	struct libusb_device *usbdev;
+	union fx_status fx_status;
+	union spartan_status spartan_status;
+	uint8_t *bindata, verify_data[32];
+	uint32_t binsize;
+	int err, i;
+
+	usb = sdi->conn;
+	drvc = sdi->driver->context;
+	devc = sdi->priv;
+
+	err = control_in(usb->devhdl,
+						CMD_STATUS,
+						CMD_STATUS_USB_STATUS,
+						fx_status.bytes,
+						4);
+	if (err) {
+		sr_err(
+				"kingst_la1010_upload_spartan_firmware(): check Cypress status failed. libusb err: %s",
+				libusb_error_name(err));
+		return err;
+	}
+
+	if (fx_status.code[0] != 0xFFFFFFFF) {
+		sr_err(
+				"kingst_la1010_upload_spartan_firmware(): wrong Cypress status: %x",
+				fx_status.code[0]);
+		return SR_ERR;
+	}
+
+	err = control_in(usb->devhdl,
+						CMD_STATUS,
+						CMD_STATUS_FX_STATUS,
+						fx_status.bytes,
+						sizeof(fx_status.bytes));
+	if (err) {
+		sr_err(
+				"kingst_la1010_upload_spartan_firmware(): check Cypress FW status failed. libusb err: %s",
+				libusb_error_name(err));
+		return err;
+	}
+
+	if ((fx_status.bytes[0] ^ fx_status.bytes[1]) != 0xFF) {
+		sr_err(
+				"kingst_la1010_upload_spartan_firmware(): wrong Cypress FW status: %x, %x",
+				fx_status.bytes[0],
+				fx_status.bytes[1]);
+		return SR_ERR;
+	}
+
+	bindata = sr_resource_load(drvc->sr_ctx,
+								SR_RESOURCE_FIRMWARE,
+								devc->profile->spartan_firmware,
+								(size_t*) &binsize,
+								0x020000);
+	if (!bindata) {
+		return SR_ERR_MALLOC;
+	}
+
+	err = control_out(usb->devhdl,
+						CMD_SPARTAN_UPLOAD,
+						0,
+						(uint8_t*) &binsize,
+						sizeof(binsize));
+	if (err) {
+		sr_err(
+				"kingst_la1010_upload_spartan_firmware(): upload Spartan firmware failed. libusb err: %s",
+				libusb_error_name(err));
+		return err;
+	}
+
+	usbdev = libusb_get_device(usb->devhdl);
+	if (usbdev) {
+		i = libusb_get_max_packet_size(usbdev, USB_UPLOAD_DATA_EP);
+
+		sr_dbg("Upload Spartan firmware using packet size %d", i);
+
+		err = upload_bindata_sync(usb->devhdl, bindata, binsize, i);
+		g_free(bindata);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): upload Spartan firmware failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+
+		g_usleep(100 * 1000);
+
+		err = control_in(usb->devhdl,
+							CMD_SPARTAN_UPLOAD,
+							0,
+							spartan_status.bytes,
+							1);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): check Spartan status failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+
+		if (spartan_status.bytes[0]) {
+			sr_err("Check Spartan returns wrong status: %d", spartan_status.bytes[0]);
+			return SR_ERR;
+		}
+
+		g_usleep(30 * 1000);
+
+		err = control_out(usb->devhdl,
+							CMD_10,
+							1,
+							NULL,
+							0);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): start Spartan failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+
+		g_usleep(40 * 1000);
+
+		err = control_in(usb->devhdl,
+							CMD_CONTROL,
+							0,
+							spartan_status.bytes,
+							2);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): check Spartan status failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+
+		/// GetVerifyData
+		verify_data[0] = 0xA3;
+		verify_data[1] = 0x09;
+		verify_data[2] = 0xC9;
+		err = control_out(usb->devhdl,
+							CMD_60,
+							0,
+							verify_data,
+							11);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): GetVerifyData out failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+		err = control_in(usb->devhdl,
+							CMD_60,
+							0,
+							verify_data,
+							18);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): GetVerifyData in failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+		/// GetVerifyData end
+
+		/// GetDeviceID
+		verify_data[0] = 0xA3;
+		verify_data[1] = 0x01;
+		verify_data[2] = 0xCA;
+		err = control_out(usb->devhdl,
+							CMD_60,
+							0,
+							verify_data,
+							3);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): GetVerifyData out failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+		err = control_in(usb->devhdl,
+							CMD_60,
+							0,
+							verify_data,
+							12);
+		if (err) {
+			sr_err(
+					"kingst_la1010_upload_spartan_firmware(): GetVerifyData in failed. libusb err: %s",
+					libusb_error_name(err));
+			return err;
+		}
+		/// GetDeviceID end
+
+	} else {
+		sr_err(
+				"Upload Spartan failed. Can't get usb device struct by device handle");
+		return SR_ERR;
+	}
+
+	return err;
+}
+
+/*
+ * Init the device for usage.
+ */
+int kingst_la1010_init_spartan(struct libusb_device_handle *handle) {
+	int err;
+
+	/*
+	 * Configure voltage threshold.
+	 */
+	err = kingst_la1010_set_logic_level(handle, 1.58);
+	if (err)
+		return err;
+
+	/*
+	 * Configure PWM channels -- two channels.
+	 */
+	err = kingst_la1010_configure_pwm(handle, 0, 50, 0, 50);
+	if (err)
+		return err;
+
+	return SR_OK;
+}
+
+int kingst_la1010_receive_data(int fd, int revents, void *cb_data) {
+	struct timeval tv;
+	struct drv_context *drvc;
+
+	(void) fd;
+	(void) revents;
+
+	drvc = (struct drv_context*) cb_data;
+	tv.tv_sec = tv.tv_usec = 0;
+	libusb_handle_events_timeout(drvc->sr_ctx->libusb_ctx, &tv);
+
+	return TRUE;
+}
+
+int kingst_la1010_acquisition_start(const struct sr_dev_inst *sdi) {
+	struct sr_dev_driver *di;
+	struct drv_context *drvc;
+	struct dev_context *devc;
+	int timeout, ret;
+
+	di = sdi->driver;
+	drvc = di->context;
+	devc = sdi->priv;
+
+	devc->ctx = drvc->sr_ctx;
+	devc->sent_samples = 0;
+	devc->cur_channel = 0;
+	devc->empty_transfer_count = 0;
+	devc->acq_aborted = FALSE;
+	memset(devc->channel_data, 0, 16 * 2);
+
+	if (kingst_la1010_configure_channels(sdi) != SR_OK) {
+		sr_err("Failed to configure channels.");
+		return SR_ERR;
+	}
+
+	timeout = get_timeout(devc);
+	usb_source_add(sdi->session, devc->ctx, timeout, kingst_la1010_receive_data,
+			drvc);
+
+	devc->convbuffer_size = (get_buffer_size(devc) / devc->num_channels) * 16
+			+ 32;
+
+	devc->convbuffer = g_try_malloc(devc->convbuffer_size);
+
+	if (devc->convbuffer) {
+		if ((ret = command_start_acquisition(sdi)) != SR_OK) {
+			kingst_la1010_acquisition_stop(sdi);
+			if (devc->convbuffer)
+				g_free(devc->convbuffer);
+			devc->convbuffer = NULL;
+			return ret;
+		}
+
+		start_transfers(sdi);
+	} else {
+		sr_err("Failed to allocate memory for data buffer.");
+		return SR_ERR_MALLOC;
+	}
+
+	return SR_OK;
+}
+
+static int command_start_acquisition(const struct sr_dev_inst *sdi) {
+	struct dev_context *devc;
+	struct sr_usb_dev_inst *usb;
+	uint64_t samplerate;
+	uint16_t division;
+	int err;
+	uint8_t data[4];
+
+	devc = sdi->priv;
+	usb = sdi->conn;
+	samplerate = devc->cur_samplerate;
+	usb = sdi->conn;
+
+	data[0] = 0;
+	err = control_out(usb->devhdl, CMD_CONTROL, CMD_CONTROL_START, data, 1);
+	if (err) {
+		sr_err("Start configure channels failed.");
+		return err;
+	}
+
+	err = control_out(usb->devhdl, CMD_SAMPLING_CONFIG, CMD_SAMPLING_CONFIG,
+			NULL, 0);
+	if (err) {
+		sr_err("Enter to sampling rate configuration mode failed.");
+		return err;
+	}
+
+	division = SAMPLING_BASE_FREQUENCY / samplerate;
+
+	err = control_out(usb->devhdl,
+	CMD_CONTROL,
+	CMD_CONTROL_SAMPLE_RATE, (uint8_t*) &division, sizeof(division));
+	if (err) {
+		sr_err("Set sample rate failed.");
+		return err;
+	}
+
+	data[0] = devc->cur_channels & 0xFF;
+	data[1] = devc->cur_channels >> 8;
+	data[2] = 0;
+	data[3] = 0;
+	err = control_out(usb->devhdl, CMD_CONTROL, CMD_CONTROL_CHAN_SELECT, data,
+			4);
+	if (err) {
+		sr_err("Set channel mask failed.");
+		return err;
+	}
+
+	data[0] = 1;
+	err = control_out(usb->devhdl, CMD_CONTROL, CMD_CONTROL_START, data, 1);
+	if (err) {
+		sr_err("Commit the channels and sample rate configuration failed.");
+		return err;
+	}
+
+	err = control_out(usb->devhdl, CMD_SAMPLING_START, CMD_SAMPLING_START, NULL,
+			0);
+	if (err) {
+		sr_err("Star sampling failed.");
+		return err;
+	}
+
+	return SR_OK;
+}
+
+int kingst_la1010_acquisition_stop(const struct sr_dev_inst *sdi) {
+	int i, ret;
+	struct sr_usb_dev_inst *usb;
+	struct dev_context *devc;
+
+	sr_dbg("kingst_la1010_acquisition_stop(): stop requested");
+	usb = sdi->conn;
+	devc = sdi->priv;
+
+	devc->acq_aborted = TRUE;
+
+	/*
+	 * There are need send request to stop sampling.
+	 */
+	ret = kingst_la1010_abort_acquisition_request(usb->devhdl);
+	if (ret)
+		sr_err(
+				"kingst_la1010_acquisition_stop(): Stop sampling error %d. libusb err: %s",
+				ret, libusb_error_name(ret));
+
+	sr_dbg("kingst_la1010_acquisition_stop(): cancel %d transfers", devc->num_transfers);
+	for (i = devc->num_transfers - 1; i >= 0; i--) {
+		if (devc->transfers[i]) {
+			ret = libusb_cancel_transfer(devc->transfers[i]);
+			if (ret != LIBUSB_ERROR_NOT_FOUND) {
+				sr_err(
+						"kingst_la1010_acquisition_stop(): cancel %d transfer error %d. libusb err: %s",
+						i, ret, libusb_error_name(ret));
+			}
+		}
+	}
+
+	return ret;
+}
+
+
+/*
+ * Configure threshold levels.
+ * Available from -4.0 to 4.0.
+ */
+int kingst_la1010_set_logic_level(struct libusb_device_handle *hdl,
+		double level) {
+	uint32_t data;
+	int err;
+
+	if (level > -0.4) {
+		if (level < 3) {
+			/*
+			 * For voltage levels between -0.399 and 2.999 data is 0x00F1YYYY
+			 * where YYYY -- is .....
+			 */
+			data = ((level + 0.4) * 302);
+			data += 0x00F10000;
+		} else {
+			/*
+			 * For voltage levels between 2.999 and 4 data is 0x0000YYYY
+			 * where YYYY -- is .....
+			 */
+			if (level > 4) {
+				level = 4;
+			}
+			data = ((level - 1.2) * 302);
+		}
+	} else {
+		/*
+		 * For voltage levels between -4 and -0.4 data is 0x02D4YYYY
+		 * where YYYY -- is .....
+		 */
+		if (level < -3.6) {
+			level = -3.6;
+		}
+		data = ((level + 3.6) * 302);
+		data += 0x02D40000;
+	}
+
+	err = control_out(hdl,
+						CMD_CONTROL,
+						CMD_CONTROL_LOG_LEVEL,
+						(uint8_t*) &data,
+						sizeof(data));
+	if (err)
+		return err;
+
+	return SR_OK;
+}
+
+/*
+ * Configure PWM channels -- two channels.
+ * For each channel: frequency between 1 kHz (1000) and 200 MHz (200000000)$
+ *										duty between 1 and 99.
+ * Frequency == 0 -- power off PWM channel.
+ */
+int kingst_la1010_configure_pwm(struct libusb_device_handle *hdl,
+								uint64_t pwm1_freq,
+								uint64_t pwm1_duty,
+								uint64_t pwm2_freq,
+								uint64_t pwm2_duty) {
+	uint32_t data[2];
+	int err;
+
+	if (pwm1_duty > 100) {
+		sr_err("Wrong PWM1 duty ratio, given %ld, but only 0 .. 100 allowed",
+				pwm1_duty);
+		pwm1_duty = 50;
+	}
+	if (pwm2_duty > 100) {
+		sr_err("Wrong PWM2 duty ratio, given %ld, but only 0 .. 100 allowed",
+				pwm2_duty);
+		pwm2_duty = 50;
+	}
+
+	if (pwm1_freq) {
+		/*
+		 * PWM data is division 800000000 to frequency
+		 */
+		pwm1_freq = PWM_BASE_FREQUENCY / pwm1_freq;
+		/*
+		 * Duty data is between '0' and 'PWM data'
+		 */
+		pwm1_duty = pwm1_freq * pwm1_duty / 100;
+	}
+
+	if (pwm2_freq) {
+		pwm2_freq = PWM_BASE_FREQUENCY / pwm2_freq;
+		pwm2_duty = pwm2_freq * pwm2_duty / 100;
+	}
+
+	data[0] = 0x00;
+	err = control_out(hdl, CMD_CONTROL, CMD_CONTROL_PWM, (uint8_t*) &data, 1);
+	if (err)
+		return err;
+
+	data[0] = pwm1_freq;
+	data[1] = pwm1_duty;
+	err = control_out(hdl, CMD_CONTROL, CMD_CONTROL_PWM_1, (uint8_t*) &data, sizeof(data));
+	if (err)
+		return err;
+
+	data[0] = pwm2_freq;
+	data[1] = pwm2_duty;
+	err = control_out(hdl, CMD_CONTROL, CMD_CONTROL_PWM_2, (uint8_t*) &data, sizeof(data));
+	if (err)
+		return err;
+
+	data[0] = 0x01;
+	err = control_out(hdl, CMD_CONTROL, CMD_CONTROL_PWM, (uint8_t*) &data, 1);
+	if (err)
+		return err;
+
+	return SR_OK;
+}
+
+int kingst_la1010_dev_open(const struct sr_dev_inst *sdi) {
+	libusb_device **devlist;
+	struct sr_dev_driver *di;
+	struct sr_usb_dev_inst *usb;
+	struct libusb_device_descriptor des;
+	struct dev_context *devc;
+	struct drv_context *drvc;
+	int ret = SR_ERR, i, device_count;
+	char connection_id[64];
+
+	di = sdi->driver;
+	drvc = di->context;
+	devc = sdi->priv;
+	usb = sdi->conn;
+
+	device_count = libusb_get_device_list(drvc->sr_ctx->libusb_ctx, &devlist);
+	if (device_count < 0) {
+		sr_err("Failed to get device list: %s.",
+				libusb_error_name(device_count));
+		return SR_ERR;
+	}
+
+	for (i = 0; i < device_count; i++) {
+		libusb_get_device_descriptor(devlist[i], &des);
+
+		if (des.idVendor != devc->profile->vid
+				|| des.idProduct != devc->profile->pid)
+			continue;
+
+		if ((sdi->status == SR_ST_INITIALIZING)
+				|| (sdi->status == SR_ST_INACTIVE)) {
+			/*
+			 * Check device by its physical USB bus/port address.
+			 */
+			usb_get_port_path(devlist[i], connection_id, sizeof(connection_id));
+			if (strcmp(sdi->connection_id, connection_id))
+				/* This is not the one. */
+				continue;
+		}
+
+		if (!(ret = libusb_open(devlist[i], &usb->devhdl))) {
+			if (usb->address == 0xff)
+				/*
+				 * First time we touch this device after FW
+				 * upload, so we don't know the address yet.
+				 */
+				usb->address = libusb_get_device_address(devlist[i]);
+		} else {
+			sr_err("Failed to open device: %s.", libusb_error_name(ret));
+			ret = SR_ERR;
+			break;
+		}
+
+		if (libusb_has_capability(LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER)) {
+			if (libusb_kernel_driver_active(usb->devhdl, USB_INTERFACE) == 1) {
+				if ((ret = libusb_detach_kernel_driver(usb->devhdl,
+				USB_INTERFACE)) < 0) {
+					sr_err("Failed to detach kernel driver: %s.",
+							libusb_error_name(ret));
+					ret = SR_ERR;
+					break;
+				}
+			}
+		}
+
+		sr_info(
+				"Opened device on %d.%d (logical) / %s (physical), " "interface %d",
+				usb->bus, usb->address, connection_id, USB_INTERFACE);
+
+		ret = SR_OK;
+
+		break;
+	}
+
+	libusb_free_device_list(devlist, 1);
+
+	return ret;
+}
+
+static void LIBUSB_CALL
+abort_acquisition_request_cb(struct libusb_transfer *transfer) {
+	libusb_free_transfer(transfer);
+}
+
+int kingst_la1010_abort_acquisition_request(libusb_device_handle *handle) {
+	struct libusb_transfer *transfer;
+	unsigned char *buffer;
+	int ret;
+
+	transfer = libusb_alloc_transfer(0);
+	if (!transfer)
+		return LIBUSB_ERROR_NO_MEM;
+	transfer->buffer = 0;
+
+	buffer = (unsigned char*) g_try_malloc(LIBUSB_CONTROL_SETUP_SIZE + 1);
+	if (!buffer) {
+		libusb_free_transfer(transfer);
+		return LIBUSB_ERROR_NO_MEM;
+	}
+
+	libusb_fill_control_setup(buffer,
+								LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,
+								CMD_CONTROL,
+								CMD_CONTROL_START,
+								0,
+								1);
+	buffer[LIBUSB_CONTROL_SETUP_SIZE] = 0;
+
+	libusb_fill_control_transfer(transfer,
+									handle,
+									buffer,
+									abort_acquisition_request_cb,
+									NULL,
+									1000);
+	transfer->flags = LIBUSB_TRANSFER_FREE_BUFFER;
+
+	ret = libusb_submit_transfer(transfer);
+	if (ret < 0) {
+		libusb_free_transfer(transfer);
+		if (transfer->buffer) {
+			g_free(transfer->buffer);
+			transfer->buffer = NULL;
+		}
+		return ret;
+	}
+
+	return ret;
+}
+
+static void finish_acquisition(const struct sr_dev_inst *sdi) {
+	struct dev_context *devc;
+
+	devc = sdi->priv;
+
+	std_session_send_df_end(sdi);
+
+	usb_source_remove(sdi->session, devc->ctx);
+
+	devc->num_transfers = 0;
+	g_free(devc->transfers);
+
+	if (devc->convbuffer) {
+		g_free(devc->convbuffer);
+		devc->convbuffer = NULL;
+	}
+
+	if (devc->stl) {
+		soft_trigger_logic_free(devc->stl);
+		devc->stl = NULL;
+	}
+}
+
+static void free_transfer(struct libusb_transfer *transfer) {
+	struct sr_dev_inst *sdi;
+	struct dev_context *devc;
+	unsigned int i;
+
+	sdi = transfer->user_data;
+	devc = sdi->priv;
+
+	libusb_free_transfer(transfer);
+	if (transfer->buffer) {
+		g_free(transfer->buffer);
+		transfer->buffer = NULL;
+	}
+
+	for (i = 0; i < devc->num_transfers; i++) {
+		if (devc->transfers[i] == transfer) {
+			devc->transfers[i] = NULL;
+			break;
+		}
+	}
+
+	devc->submitted_transfers--;
+
+	if (devc->submitted_transfers == 0)
+		finish_acquisition(sdi);
+}
+
+static void resubmit_transfer(struct libusb_transfer *transfer) {
+	int ret;
+
+	if ((ret = libusb_submit_transfer(transfer)) == LIBUSB_SUCCESS)
+		return;
+
+	sr_err("%s: %s", __func__, libusb_error_name(ret));
+	free_transfer(transfer);
+
+}
+
+/*
+ * Sampling data same as Saleae Logic16.
+ */
+static size_t convert_sample_data(struct dev_context *devc,
+									uint8_t *dest,
+									size_t destcnt,
+									const uint8_t *src,
+									size_t srccnt) {
+	uint16_t *channel_data;
+	int i, cur_channel;
+	size_t ret = 0;
+	uint16_t sample, channel_mask;
+
+	srccnt /= 2;
+
+	channel_data = devc->channel_data;
+	cur_channel = devc->cur_channel;
+
+	while (srccnt--) {
+		sample = src[0] | (src[1] << 8);
+		src += 2;
+
+		channel_mask = devc->channel_masks[cur_channel];
+
+		for (i = 0; i < 16; ++i, sample >>= 1)
+			if (sample & 1)
+				channel_data[i] |= channel_mask;
+
+		if (++cur_channel == devc->num_channels) {
+			cur_channel = 0;
+			if (destcnt < 16 * 2) {
+				sr_err("Conversion buffer too small! dstcnt %ld, srccnt %ld",
+						destcnt, srccnt);
+				break;
+			}
+			memcpy(dest, channel_data, 16 * 2);
+			memset(channel_data, 0, 16 * 2);
+			dest += 16 * 2;
+			ret += 16;
+			destcnt -= 16 * 2;
+		}
+	}
+
+	devc->cur_channel = cur_channel;
+
+	return ret;
+}
+
+static void LIBUSB_CALL
+receive_transfer(struct libusb_transfer *transfer) {
+	struct sr_dev_inst *sdi;
+	struct dev_context *devc;
+	gboolean packet_has_error = FALSE;
+	size_t num_samples, new_samples;
+	int trigger_offset, pre_trigger_samples;
+	struct sr_datafeed_logic logic;
+	struct sr_datafeed_packet packet;
+
+	sdi = transfer->user_data;
+	devc = sdi->priv;
+
+	/*
+	 * If acquisition has already ended, just free any queued up
+	 * transfer that come in.
+	 */
+	if (devc->acq_aborted) {
+
+		free_transfer(transfer);
+		return;
+	}
+
+	switch (transfer->status) {
+	case LIBUSB_TRANSFER_NO_DEVICE:
+		sr_err("receive_transfer(): no device");
+		kingst_la1010_acquisition_stop(sdi);
+		free_transfer(transfer);
+		return;
+	case LIBUSB_TRANSFER_COMPLETED:
+	case LIBUSB_TRANSFER_TIMED_OUT: /* We may have received some data though. */
+		break;
+	default:
+		packet_has_error = TRUE;
+		break;
+	}
+
+	if (transfer->actual_length == 0 || packet_has_error) {
+		devc->empty_transfer_count++;
+		if (devc->empty_transfer_count > MAX_EMPTY_TRANSFERS) {
+			sr_err("receive_transfer(): MAX_EMPTY_TRANSFERS exceeded");
+			kingst_la1010_acquisition_stop(sdi);
+			free_transfer(transfer);
+		} else {
+			sr_err(
+					"receive_transfer(): resubmit transfer due error: actual_length %d, has_error %d",
+					transfer->actual_length, packet_has_error);
+			resubmit_transfer(transfer);
+		}
+		return;
+	} else {
+		devc->empty_transfer_count = 0;
+	}
+
+	logic.data = devc->convbuffer;
+	logic.unitsize = 2;
+
+	packet.type = SR_DF_LOGIC;
+	packet.payload = &logic;
+
+	new_samples = convert_sample_data(devc,
+										devc->convbuffer,
+										devc->convbuffer_size,
+										(uint8_t*) transfer->buffer,
+										transfer->actual_length);
+	if (new_samples == 0) {
+		if (transfer->actual_length) {
+			sr_err("receive_transfer(): convert data failed");
+			kingst_la1010_acquisition_stop(sdi);
+			free_transfer(transfer);
+			return;
+		} else {
+			resubmit_transfer(transfer);
+			return;
+		}
+	}
+
+	if (devc->trigger_fired) {
+		if (devc->limit_samples
+				&& (new_samples > devc->limit_samples - devc->sent_samples))
+			new_samples = devc->limit_samples - devc->sent_samples;
+		logic.length = new_samples * 2;
+		sr_session_send(sdi, &packet);
+		devc->sent_samples += new_samples;
+	} else {
+		trigger_offset = soft_trigger_logic_check(devc->stl,
+													devc->convbuffer,
+													new_samples * 2,
+													&pre_trigger_samples);
+		if (trigger_offset > -1) {
+			devc->sent_samples += pre_trigger_samples;
+			packet.type = SR_DF_LOGIC;
+			packet.payload = &logic;
+			num_samples = new_samples - trigger_offset;
+			if (devc->limit_samples
+					&& (num_samples > devc->limit_samples - devc->sent_samples))
+				num_samples = devc->limit_samples - devc->sent_samples;
+			logic.length = num_samples * 2;
+			logic.data = devc->convbuffer + trigger_offset * 2;
+			sr_session_send(sdi, &packet);
+			devc->sent_samples += num_samples;
+
+			devc->trigger_fired = TRUE;
+		}
+	}
+
+	if (devc->limit_samples && (devc->sent_samples >= devc->limit_samples)) {
+		sr_dbg("receive_transfer(): samples limit reached %ld",
+				devc->sent_samples);
+		kingst_la1010_acquisition_stop(sdi);
+		free_transfer(transfer);
+	} else
+		resubmit_transfer(transfer);
+}
+
+int kingst_la1010_configure_channels(const struct sr_dev_inst *sdi) {
+	struct dev_context *devc;
+	const GSList *l;
+	struct sr_channel *ch;
+	uint16_t channel_bit;
+
+	devc = sdi->priv;
+	devc->num_channels = 0;
+	devc->cur_channels = 0;
+	for (l = sdi->channels; l; l = l->next) {
+		ch = (struct sr_channel*) l->data;
+		if (ch->enabled == FALSE)
+			continue;
+
+		channel_bit = 1 << (ch->index);
+		devc->cur_channels |= channel_bit;
+		devc->channel_masks[devc->num_channels++] = channel_bit;
+	}
+
+	return SR_OK;
+}
+
+static unsigned int to_bytes_per_ms(unsigned int samplerate, uint8_t num_channels) {
+	unsigned long result = samplerate * num_channels / 8;
+	return result / 1000;
+}
+
+static size_t get_buffer_size(struct dev_context *devc) {
+	size_t s;
+
+	/*
+	 * This transfer size used by KingstVIS
+	 */
+	s = devc->num_channels * devc->cur_samplerate / 128;
+	return (s + 511) & ~511;
+}
+
+static unsigned int get_number_of_transfers(struct dev_context *devc) {
+	unsigned int n;
+
+	/* Total buffer size should be able to hold about 500ms of data. */
+	n = (500 * to_bytes_per_ms(devc->cur_samplerate, devc->num_channels))
+			/ get_buffer_size(devc);
+
+//	if (n > NUM_SIMUL_TRANSFERS)
+//		return NUM_SIMUL_TRANSFERS;
+
+	return n;
+}
+
+static unsigned int get_timeout(struct dev_context *devc) {
+	size_t total_size;
+	unsigned int timeout;
+
+	total_size = get_buffer_size(devc) * get_number_of_transfers(devc);
+	timeout = total_size
+			/ to_bytes_per_ms(devc->cur_samplerate, devc->num_channels);
+	return timeout + timeout / 4; /* Leave a headroom of 25% percent. */
+}
+
+static int start_transfers(const struct sr_dev_inst *sdi) {
+	struct dev_context *devc;
+	struct sr_usb_dev_inst *usb;
+	struct sr_trigger *trigger;
+	struct libusb_transfer *transfer;
+	unsigned int i, num_transfers;
+	int timeout, ret;
+	int pre_trigger_samples;
+	unsigned char *buf;
+	size_t size;
+
+	sr_dbg("start_transfers():");
+
+	devc = sdi->priv;
+	usb = sdi->conn;
+
+	devc->sent_samples = 0;
+	devc->acq_aborted = FALSE;
+	devc->empty_transfer_count = 0;
+
+	if ((trigger = sr_session_trigger_get(sdi->session))) {
+		pre_trigger_samples = 0;
+		if (devc->limit_samples > 0)
+			pre_trigger_samples = (devc->capture_ratio * devc->limit_samples) / 100;
+		devc->stl = soft_trigger_logic_new(sdi, trigger, pre_trigger_samples);
+		if (!devc->stl)
+			return SR_ERR_MALLOC;
+		devc->trigger_fired = FALSE;
+
+		sr_dbg("Trigger was enabled");
+	} else
+		devc->trigger_fired = TRUE;
+
+	sr_dbg("Samplerate: %ld", devc->cur_samplerate);
+	sr_dbg("Number of channels: %d", devc->num_channels);
+
+	num_transfers = get_number_of_transfers(devc);
+	sr_dbg("Number transfers was calculated: %d (0x%X)", num_transfers,
+			num_transfers);
+
+	size = get_buffer_size(devc);
+	sr_dbg("Buffer size for each transfer was calculated: %ld (0x%lX)", size,
+			size);
+
+	devc->submitted_transfers = 0;
+
+	devc->transfers = g_try_malloc0(sizeof(*devc->transfers) * num_transfers);
+	if (!devc->transfers) {
+		sr_err("USB transfers malloc failed.");
+		return SR_ERR_MALLOC;
+	}
+
+	timeout = get_timeout(devc);
+	sr_dbg("Timeout for each transfer was calculated: %d (0x%X)", timeout,
+			timeout);
+
+	for (i = 0; i < num_transfers; i++) {
+		if (!(buf = g_try_malloc(size))) {
+			sr_err("USB transfer buffer malloc failed.");
+			return SR_ERR_MALLOC;
+		}
+		transfer = libusb_alloc_transfer(0);
+		libusb_fill_bulk_transfer(transfer, usb->devhdl,
+		USB_SAMPLING_DATA_EP, buf, size, receive_transfer, (void*) sdi,
+				timeout);
+
+		if ((ret = libusb_submit_transfer(transfer)) != 0) {
+			libusb_free_transfer(transfer);
+			g_free(buf);
+			if (i == 0) {
+				sr_err("Failed to submit transfer: %s.",
+						libusb_error_name(ret));
+				kingst_la1010_acquisition_stop(sdi);
+				return SR_ERR;
+			} else {
+				break;
+			}
+		}
+		devc->transfers[i] = transfer;
+		devc->submitted_transfers++;
+	}
+
+	devc->num_transfers = i;
+	sr_info("%d transfers was submited: data size 0x%lx, timeout %d",
+			devc->num_transfers, size, timeout);
+
+	std_session_send_df_header(sdi);
+
+	return SR_OK;
+}
+
+static int control_in(libusb_device_handle *handle,
+						uint8_t request,
+						uint16_t value,
+						uint8_t *data,
+						uint16_t size) {
+	int actual_length = 0;
+	uint8_t empty_data[1] = { 0 };
+
+	actual_length = libusb_control_transfer(handle,
+												LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR,
+												request,
+												value,
+												0,
+												data == NULL ? empty_data : data,
+												size,
+												USB_TIMEOUT);
+	if (actual_length < 0) {
+		sr_err("Failed to send 'control in' request to device: %s.",
+				libusb_error_name(actual_length));
+		return actual_length;
+	} else if (actual_length != size) {
+		sr_err(
+				"Wrong response size for 'control in' request: expected %d given %d.",
+				size, actual_length);
+		return SR_ERR;
+	}
+
+	return SR_OK;
+}
+
+int control_out(libusb_device_handle *handle,
+				uint8_t request,
+				uint16_t value,
+				uint8_t *data,
+				uint16_t size) {
+	int actual_length = 0;
+	uint8_t empty_data[1] = { 0 };
+
+	actual_length = libusb_control_transfer(handle,
+			LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR, request, value, 0,
+			data == NULL ? empty_data : data, size,
+			USB_TIMEOUT);
+	if (actual_length < 0) {
+		sr_err("Failed to send 'control out' request to device: %s.",
+				libusb_error_name(actual_length));
+		return actual_length;
+	} else if (actual_length != size) {
+		sr_err(
+				"Wrong response size for 'control out' request: expected %d given %d.",
+				size, actual_length);
+		return SR_ERR;
+	}
+
+	return SR_OK;
+}
+
+int upload_bindata_sync(libusb_device_handle *handle,
+						uint8_t *bindata,
+						int size,
+						int trans_size) {
+	int data_len, err, actual_len;
+
+	while (size > 0) {
+		data_len = size;
+		if (data_len > trans_size) {
+			data_len = trans_size;
+		}
+		err = libusb_bulk_transfer(handle,
+									USB_UPLOAD_DATA_EP,
+									bindata,
+									data_len,
+									&actual_len,
+									100);
+		if (err) {
+			sr_err("Failed to upload Spartan firmware: %s.",
+						libusb_error_name(err));
+			return err;
+		} else if (actual_len != data_len) {
+			sr_err(
+					"Failed to upload Spartan firmware: sent %d but actual sent %d.",
+					data_len, actual_len);
+			return SR_ERR_DATA;
+		}
+		size -= actual_len;
+		bindata += actual_len;
+	}
+	err = libusb_bulk_transfer(handle,
+								USB_UPLOAD_DATA_EP,
+								(unsigned char*) &data_len, // fake buffer for 0-sized transfer (passing NULL may be not working in some systems)
+								0,
+								&actual_len,
+								100);
+	if (err) {
+		sr_err("Failed to upload Spartan firmware: %s.",
+					libusb_error_name(err));
+		return err;
+	}
+	return size;
+}
+
+struct dev_context* kingst_la1010_dev_new(void) {
+	struct dev_context *devc;
+
+	devc = g_malloc0(sizeof(struct dev_context));
+	devc->profile = NULL;
+	devc->fw_updated = 0;
+	devc->cur_samplerate = 0;
+	devc->limit_samples = 0;
+	devc->capture_ratio = 0;
+	devc->num_channels = 0;
+	devc->convbuffer = NULL;
+	devc->stl = NULL;
+
+	return devc;
+}
+
diff --git a/src/hardware/kingst-la1010/protocol.h b/src/hardware/kingst-la1010/protocol.h
new file mode 100644
index 00000000..0c9d070c
--- /dev/null
+++ b/src/hardware/kingst-la1010/protocol.h
@@ -0,0 +1,187 @@
+/*
+ * This file is part of the libsigrok project.
+ *
+ * Copyright (C) 2018 Alexandr Ugnenko <ugnenko@mail.ru>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef LIBSIGROK_HARDWARE_KINGST_LA1010_PROTOCOL_H
+#define LIBSIGROK_HARDWARE_KINGST_LA1010_PROTOCOL_H
+
+#include <stdint.h>
+#include <glib.h>
+#include <string.h>
+#include <libsigrok/libsigrok.h>
+#include "libsigrok-internal.h"
+
+#define LOG_PREFIX "kingst-la1010"
+
+#define USB_INTERFACE		0
+#define USB_CONFIGURATION	1
+#define NUM_TRIGGER_STAGES	4
+
+#define USB_UPLOAD_DATA_EP      0x02
+#define USB_SAMPLING_DATA_EP    0x86
+
+#define MAX_RENUM_DELAY_MS	3000
+#define NUM_SIMUL_TRANSFERS	8
+#define MAX_EMPTY_TRANSFERS	(NUM_SIMUL_TRANSFERS * 2)
+
+#define NUM_CHANNELS		16
+
+#define KINGST_LA1010_REQUIRED_VERSION_MAJOR	1
+
+#define MAX_3BIT_SAMPLE_RATE	SR_MHZ(100)
+#define MAX_16BIT_SAMPLE_RATE	SR_MHZ(16)
+
+/* 6 delay states of up to 256 clock ticks */
+#define MAX_SAMPLE_DELAY	(6 * 256)
+
+#define DEV_CAPS_16BIT_POS	0
+
+#define DEV_CAPS_16BIT		(1 << DEV_CAPS_16BIT_POS)
+
+/* Protocol commands */
+#define CMD_10                          0x10
+#define CMD_CONTROL                     0x20
+#define CMD_SAMPLING_START              0x30
+#define CMD_SAMPLING_CONFIG             0x38
+#define CMD_STATUS                      0xA2
+#define CMD_SPARTAN_UPLOAD              0x50
+#define CMD_60                          0x60
+
+#define CMD_CONTROL_START               0x0000
+#define CMD_STATUS_FX_STATUS            0x0008
+#define CMD_CONTROL_END                 0x0001
+#define CMD_CONTROL_PWM                 0x0002
+#define CMD_STATUS_USB_STATUS           0x0020
+#define CMD_CONTROL_SAMPLE_RATE         0x002E
+#define CMD_CONTROL_CHAN_SELECT         0x0030
+#define CMD_CONTROL_LOG_LEVEL           0x0048  // electric signal level (Volts)
+#define CMD_CONTROL_PWM_1               0x0070
+#define CMD_CONTROL_PWM_2               0x0078
+
+#define SAMPLING_BASE_FREQUENCY         800000000
+#define PWM_BASE_FREQUENCY              200000000
+
+enum voltage_range {
+	VOLTAGE_RANGE_TTL,
+	VOLTAGE_RANGE_5_V,
+	VOLTAGE_RANGE_3_3_V,
+	VOLTAGE_RANGE_3_V,
+	VOLTAGE_RANGE_2_5_V,
+	VOLTAGE_RANGE_1_8_V,
+	VOLTAGE_RANGE_1_5_V,
+};
+
+struct pwm_data {
+	uint64_t freq;
+	uint64_t duty;
+	uint8_t enabled;
+};
+
+struct kingst_la1010_profile {
+	uint16_t vid;
+	uint16_t pid;
+
+	const char *vendor;
+	const char *model;
+	const char *model_version;
+
+	const char *fx_firmware;
+	const char *spartan_firmware;
+
+	uint32_t dev_caps;
+
+	const char *usb_manufacturer;
+	const char *usb_product;
+};
+
+struct dev_context {
+	const struct kingst_la1010_profile *profile;
+	/*
+	 * Since we can't keep track of an fx2lafw device after upgrading
+	 * the firmware (it renumerates into a different device address
+	 * after the upgrade) this is like a global lock. No device will open
+	 * until a proper delay after the last device was upgraded.
+	 */
+	int64_t fw_updated;
+
+	const uint64_t *samplerates;
+	int num_samplerates;
+
+	uint64_t cur_samplerate;
+	uint64_t limit_samples;
+
+	uint64_t capture_ratio;
+
+	struct pwm_data pwm[2];
+
+	enum voltage_range selected_voltage_level;
+
+	double user_defined_level;
+
+	gboolean trigger_fired;
+	gboolean acq_aborted;
+	struct soft_trigger_logic *stl;
+
+	int submitted_transfers;
+	int empty_transfer_count;
+
+	unsigned int num_transfers;
+	struct libusb_transfer **transfers;
+	struct sr_context *ctx;
+
+	uint16_t cur_channels;
+	int num_channels;
+	int cur_channel;
+	uint16_t channel_masks[16];
+	uint16_t channel_data[16];
+	uint64_t sent_samples;
+	uint8_t *convbuffer;
+	size_t convbuffer_size;
+};
+
+union fx_status {
+	uint8_t bytes[8];
+	uint32_t code[2];
+};
+
+union spartan_status {
+	uint8_t bytes[4];
+	uint32_t code;
+};
+
+SR_PRIV struct dev_context* kingst_la1010_dev_new(void);
+SR_PRIV int kingst_la1010_has_fx_firmware(struct libusb_device_handle *hdl);
+int kingst_la1010_upload_cypress_firmware(struct sr_context *ctx,
+											struct libusb_device_handle *hdl,
+											const struct kingst_la1010_profile *prof);
+SR_PRIV int kingst_la1010_upload_spartan_firmware(const struct sr_dev_inst *sdi);
+SR_PRIV int kingst_la1010_init_spartan(struct libusb_device_handle *handle);
+SR_PRIV int kingst_la1010_dev_open(const struct sr_dev_inst *sdi);
+SR_PRIV int kingst_la1010_abort_acquisition_request(libusb_device_handle *handle);
+SR_PRIV int kingst_la1010_acquisition_start(const struct sr_dev_inst *sdi);
+SR_PRIV int kingst_la1010_acquisition_stop(const struct sr_dev_inst *sdi);
+SR_PRIV int kingst_la1010_set_logic_level(struct libusb_device_handle *hdl, double level);
+SR_PRIV int kingst_la1010_receive_data(int fd, int revents, void *cb_data);
+SR_PRIV int kingst_la1010_configure_channels(const struct sr_dev_inst *sdi);
+SR_PRIV int kingst_la1010_configure_pwm(struct libusb_device_handle *hdl,
+										uint64_t pwm1_freq,
+										uint64_t pwm1_duty,
+										uint64_t pwm2_freq,
+										uint64_t pwm2_duty);
+
+#endif
-- 
2.17.1

